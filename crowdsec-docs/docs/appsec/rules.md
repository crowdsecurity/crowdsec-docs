---
id: rules
title: CrowdSec Appsec rules
sidebar_position: 1
---

<!--

 describe the overall rule (waap rules) organization, relevant section.
 explain the DSL
 speak a bit about how to write yours and how to write waap-tests in the hub (kka)
 how to debug them

-->
## CrowdSec AppSec rules type

Rules are the core of the **AppSec component**. They are used to detect and block attacks.

There are 2 types of rules:
 - **In-band rules** are evaluated synchronously and will block the processing of the request until they are evaluated thus allowing a real-time remediation
 - **Out-band rules** Out-band rules are dealt with asynchronously and will not delay the processing of the request. They won't allow remediation *at first sight* but are very useful for handling expensive evaluations or as part of a more complex detection logic (eg, blocking an exploit that spans multiple requests).

**In-band rules** and **out-band rules** differ slightly in their **default** behavior when a rule matches:
 - When an **in-band rule** matches:
   -  an **alert** is created inside CrowdSec: allowing immediate and long-term remediation against the offending IP.
   -  Note: No **event** will be generated by default.
 - When an **out-band rule** matches
   - An **event** will be generated and sent through the normal **parsers/scenarios pipeline**, allowing the detection of more complex behaviors. 
   - Note: no **alert** will be generated from this out-band rule only, the **parsers/scenarios pipeline** is responsible for raising **alerts** from processed **events**


## Rules File Format

The rule files share some common directives with the scenarios:
 - a `name` and `description`
 - a `rules` section describing the rule to match the HTTP request
 - [a label section](https://doc.crowdsec.net/docs/next/scenarios/format/#labels)


```yaml
name: crowdsecurity/example-rule
description: "Detect example pattern"
rules:
  - zones:
    - URI
    transform:
    - lowercase
    match:
      type: contains
      value: this-is-a-appsec-rule-test
labels:
  type: exploit
  service: http
  behavior: "http:exploit"
  confidence: 3
  spoofable: 0
  label: "A good description of the rule"
  classification:
   - cve.CVE-...
   - attack....
```

The `rules` contain one or more conditions that can be linked together by an operator (`or`/`and`).
Each condition contains:


## A target
 - _(mandatory)_ `zones` one or more of:
   - `ARGS`: Query string parameters
   - `ARGS_NAMES`: Name of the query string parameters
   - `BODY_ARGS`: Body args
   - `BODY_ARGS_NAMES`: Name of the body args
   - `HEADERS`: HTTP headers sent in the request
   - `METHOD`: HTTP method of the request
   - `PROTOCOL`: HTTP protocol used in the query (HTTP/1.0, HTTP/1.1, ...)
   - `URI`: The URI of the request
 - _(optional)_ `variables` containing one or more variable names to restrict the matching operation to (only relevant for `ARGS`, `BODY_ARGS` and `HEADERS`)

```yaml
#match only in 'foo' and 'bar' query string parameters
 - zones:
    - ARGS
   variables:
    - foo
    - bar
---
#match in any args or part of the URI
 - zones:
    - URI
    - ARGS
```

## A matching operation

 - _(mandatory)_ `match` containing both:
   - _(mandatory)_ `type` indicates the matching method, one of:
     - `regex`: matches _target_ against value (_value_ is a RE2 regexp)
     - `equal`: _target_ is a string equal to _value_
     - `startsWith`: _target_ starts with _value_
     - `endsWith`: _target_ ends with _value_
     - `contains`: _target_ contains value
     - `libinjectionSQL`: _target_ is detected by lib injection SQL
     - `libinjectionXSS`: _target_ is detected by lib injection XSS
     - `gt`: _target_ is greater than _value_
     - `lt`: _target_ is lower than _value_
     - `ge`: _target_ is greater or equal to _value_
     - `le`: _target_ is lower or equal to _value_
  
   - _(mandatory)_ `value` a string that is compared to the _target_
 - _(optional)_ `transform` section, containing one or more operation that will be applied on _target_ before performing the match operation:
   - `lowercase`
   - `uppercase`
   - `b64decode` : base64 decode
   - `hexdecode` : hex decode
   - `length` : transform _target_ to a number representing the string's length

```yaml
# we want the query parameter foo to be equal to 'toto'
 - zones:
   - ARGS
   variables:
   - foo
   match:
    type: equal
    value: toto
---
# we want URI to contain any variation of 'blah' (ie. blah BLah BlAH ...)
  - zones:
    - URI
    tranform:
    - uppercase 
    match:
      type: contains
      value: BLAH
```


### Seclang Support

The application security component is also able to load rule in the seclang format (modsecurity rules).

We recommend using this format only to use existings rules you may have.

Modsecurity syntax support is provided by [coraza](https://github.com/corazawaf/coraza/), and the reference documentation is available [here](https://coraza.io/docs/seclang/syntax/).

There are 2 ways to provide crowdsec with seclang rules:
 - Provide rules directly by using the `seclang_rules` parameter in your rule file
 - Provide a file containing the rules by using the `seclang_rules_file` parameter in your rule file. The file must be located inside crowdsec data directory

 :::info
The default paths for the data directory per OS:
- Linux: `/var/lib/crowdsec/data`
- Freebsd: `/var/db/crowdsec/data`
- Windows: `C:\programdata\crowdsec\data`
:::

```yaml
name: example/secrules
seclang_rules:
 - SecRule ARGS:ip ";" "t:none,log,deny,msg:'semi colon test',id:2"
seclang_files_rules:
 - my-rule-file.conf
```

<!-- @sbl cadeau
## Writing your own rules

### Rules


#### In-band rules


#### Out-band rules

Now, we will write an out-band rule to detect a specific behaviour.

Let's assume that we have a web application that exposes an API endpoint on `/api` with multiple actions, and that always return a `200` status code, even if the action failed:
 - Login
 - Get information about a product
 
It is not possible to detect a brute-force attack on this endpoint by looking only at the logs, as the application will always return a `200` status code, meaning we cannot distinguish a login attempt from a simple information request.

But we can write an out-band rule that will generate an event for any login attempt, and a scenario that will used a standard [leaky bucket](/scenarios/format.md) to detect brute-force attacks.

Here is an example of a login request:
```http
POST /api HTTP/1.1

Content-Type: application/json

{
  "action": "login",
  "username": "admin",
  "password": "password"
}
```
 
First, our waap-rule:

```yaml
type: waap-rule
name: example/bf-detection
description: "Always matches on login attempts"
rules:
  - body_type: json
    and:
    - zones:
        - METHOD
      match:
        type: equal
        value: POST
	- zones:
		- URI
	  match:
	  	type: equal
		value: /api
    - zones:
        - BODY_ARGS
      variables:
        - login
      match:
        type: regex
        value: ".+"
    - zones:
        - BODY_ARGS
      variables:
        - password
      match:
        type: regex
        value: ".+"

### Testing


## Debugging rules
-->
