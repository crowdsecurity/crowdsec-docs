---
id: kubernetes
title: Kubernetes
pagination_prev: getting_started/intro
pagination_next: getting_started/health_check
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';


# Kubernetes Deployment

Before getting started, it is advised to read the
[introduction](/unversioned/getting_started/introduction.mdx) page to understand
the prerequisites and concepts for running CrowdSec.

## Requirements

- [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl)
- [Helm](https://helm.sh/docs/intro/install/)

Even if an installation could be possible without Helm, it's not documented for now.

## Helm Repository Installation

Add the CrowdSec helm repository to your Helm installation:

```bash
helm repo add crowdsec https://crowdsecurity.github.io/helm-charts
helm repo update
```

### Install Security Engine

Once the helm repository is added, first you need to write your crowdsec-values.yaml file. You can use the following example:

```yaml
# for raw logs format: json or cri (docker|containerd)
container_runtime: containerd
agent:
  # Specify each pod whose logs you want to process
  acquisition:
    # The namespace where the pod is located
    - namespace: traefik
      # The pod name
      podName: traefik-*
      # as in crowdsec configuration, we need to specify the program name to find a matching parser
      program: traefik
  env:
    - name: COLLECTIONS
      value: "crowdsecurity/traefik"
lapi:
  env:
    # To enroll the Security Engine to the console
    - name: ENROLL_KEY
      value: "<enroll-key>"
    - name: ENROLL_INSTANCE_NAME
      value: "my-k8s-cluster"
    - name: ENROLL_TAGS
      value: "k8s linux test"
```

Acquisition is done by reading logs directly from pods. You select which pods to
watch thanks to `namespace` and `podName`, and you have to tag the logs with a
program so CrowdSec knows which parser should handle them. For example, if you
set program: nginx, the nginx parser will pick them up. CrowdSec will
automatically attach to the right pods and feed the logs into the right parsers.

<details>
    <summary>Why `program` and not `type` ?</summary>
In standard standalone setups, documentation states that the labels should be
name `type` with the type being the parsed log program (eg nginx, traefik). A
transformation from `type` to `program` is done by the first stage parser
`crowdsecurity/syslog-logs` which is not relevant in a Kubernetes context.
</details>

<details>
    <summary>How collections fit in kubernetes environment?</summary>

Collections are "recipes" for understanding logs; they don’t find pods on their
own. You choose which pods to read, and you tag those logs with a program (like
nginx or traefik). When the tag matches what a collection expects, its rules
run; if it doesn’t, they stay idle. One log stream can match several collections
if the tags fit.
</details>

Note that the chart needs for some persistent volume. To make the
installation work, you have to either set a default `storageClassName` or set
it through the `values.yaml`:
```yaml
lapi:
  persistentVolume:
    data:
      storageClassName: nfs-client
    config:
      storageClassName: nfs-client
```


If you want more information about the configuration, you can check the default
[values.yaml](https://artifacthub.io/packages/helm/crowdsec/crowdsec#values)


Then, you can install the Security Engine with the following command:

```bash
# Create a namespace for crowdsec
kubectl create ns crowdsec
# Install the helm chart
helm install crowdsec crowdsec/crowdsec -n crowdsec -f crowdsec-values.yaml
```

Check the installation status:
```bash
kubectl -n crowdsec get pods
```

```bash title="Command Output"
NAME READY STATUS RESTARTS AGE
crowdsec-agent-kf9fr 1/1 Running 0 34s
crowdsec-lapi-777c469947-jbk9q 1/1 Running 0 34s
```

### A word About Source IPs

For CrowdSec to do its job in Kubernetes, it needs to see the real client IP. If
not, every request will just look like it’s coming from your ingress controller
or load balancer, and CrowdSec won’t know who the actual attacker is. To fix
this, you need to make sure the original IP gets passed through. Depending on
your setup, that could mean turning on the proxy-protocol in your ingress,
setting externalTrafficPolicy: Local on Services, or tweaking things like
real_ip_header and set_real_ip_from if you’re using NGINX. The exact steps
depend on your stack, but the main idea is simple: CrowdSec needs the real IP,
not the proxy’s.

### A Word About Remediation Component

Installing the CrowdSec Engine as a local API and log processors is very useful
to detect aggressive behaviors, but no remediation action will be taken upon it.
To get remediation actions, one has to install remediation component. As of now
remediation can only happen at ingress level.

For now, we support:

* [Ingress Nginx](/bouncers/ingress-nginx.mdx)
* [Traefik Ingress](/bouncers/traefik.mdx)

Please note that the [Traefik Kubernetes Ingress (Third party
development)](https://plugins.traefik.io/plugins/6335346ca4caa9ddeffda116/crowdsec-bouncer-traefik-plugin))
is maintained outside CrowdSec

Before installing the remediation component, you need to generate API key to communicate with the LAPI.

:::info
If you **have persistentVolumes enabled** in `values.yaml`, you can generate the api key directly from the LAPI pod:

```bash
kubectl -n crowdsec exec -it crowdsec-lapi-<pod-id> -- cscli bouncers add my-bouncer-name
```

Else you **don't have persistentVolumes enabled**, you need to specify your key
in the crowdsec helm `values.yaml` file:

```yaml
lapi:
  env:
    - name: BOUNCER_KEY_<name>
      value: "<bouncer-key>"
```
example:
```yaml
lapi:
  env:
    - name: BOUNCER_KEY_traefik
      value: "mysecretkey12345"
```
:::

### A word about databases

By default, CrowdSec uses a SQLite database, which does not support replication.
In a Kubernetes environment, this limitation prevents the Local API from being
replicated.

For production deployments on Kubernetes, we recommend using a database engine
that can be deployed in a replicated or highly available way, such as MariaDB or
PostgreSQL. You can leverage existing operators to manage these databases:
* [mariadb operator](https://mariadb.com/resources/blog/get-started-with-mariadb-in-kubernetes-and-mariadb-operator/)
* [postgresql operator](https://github.com/cloudnative-pg/cloudnative-pg)

Configuration those databases is out of scope of this documentation.
<!-- We want to create blogpost where we do it -->

:::warning

SQLite may be suitable for testing or low traffic clusters, but it is not
recommended for Kubernetes production deployments. Besides the lack of
replication, SQLite can also become a performance bottleneck under heavy load.

:::

## Next Steps?

Great, you now have CrowdSec installed on your system. Within the [post
installation steps](/getting_started/next_steps.mdx) you will find the next
steps to configure and optimize your installation.
