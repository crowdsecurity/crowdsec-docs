---
id: kubernetes
title: Kubernetes
pagination_prev: getting_started/intro
pagination_next: getting_started/health_check
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';


# Install on Kubernetes

New to CrowdSec? Start with the
[introduction](/unversioned/getting_started/introduction.mdx) to understand the
components and prerequisites.

This page installs the **Security Engine** (detection). For blocking, install a
[Remediation Component](/bouncers/intro.md) after the engine is running.

## Requirements

- [kubectl](https://kubernetes.io/docs/tasks/tools/#kubectl)
- [Helm](https://helm.sh/docs/intro/install/)

You can install without Helm, but it is not documented yet.

## Helm Repository Installation

Add the CrowdSec helm repository to your Helm installation:

```bash
helm repo add crowdsec https://crowdsecurity.github.io/helm-charts
helm repo update
```

### Install the Security Engine

Once the Helm repository is added, create a `crowdsec-values.yaml` file. You can start with this example:

```yaml
# for raw logs format: json or cri (docker|containerd)
container_runtime: containerd
agent:
  # Specify each pod whose logs you want to process
  acquisition:
    # The namespace where the pod is located
    - namespace: traefik
      # The pod name
      podName: traefik-*
      # as in crowdsec configuration, we need to specify the program name to find a matching parser
      program: traefik
  env:
    - name: COLLECTIONS
      value: "crowdsecurity/traefik"
lapi:
  env:
    # To enroll the Security Engine to the console
    - name: ENROLL_KEY
      value: "<enroll-key>"
    - name: ENROLL_INSTANCE_NAME
      value: "my-k8s-cluster"
    - name: ENROLL_TAGS
      value: "k8s linux test"
```

Acquisition is done by reading logs directly from pods. You select which pods to
watch thanks to `namespace` and `podName`, and you have to tag the logs with a
program so CrowdSec knows which parser should handle them. For example, if you
set program: nginx, the nginx parser will pick them up. CrowdSec will
automatically attach to the right pods and feed the logs into the right parsers.

<details>
    <summary>Why `program` and not `type` ?</summary>

In standard standalone setups, documentation states that the labels should be
name `type` with the type being the parsed log program (eg nginx, traefik). A
transformation from `type` to `program` is done by the first stage parser
`crowdsecurity/syslog-logs` which is not relevant in a Kubernetes context.
</details>

<details>
    <summary>How collections fit in kubernetes environment?</summary>

Collections are "recipes" for understanding logs; they don’t find pods on their
own. You choose which pods to read, and you tag those logs with a program (like
nginx or traefik). When the tag matches what a collection expects, its rules
run; if it doesn’t, they stay idle. One log stream can match several collections
if the tags fit.
</details>

For full configuration options, see the default
[values.yaml](/docs/next/configuration/values_parameters)

Then, you can install the Security Engine with the following command:

```bash
# Create a namespace for crowdsec
kubectl create ns crowdsec
# Install the helm chart
helm install crowdsec crowdsec/crowdsec -n crowdsec -f crowdsec-values.yaml
```

Check the installation status:
```bash
kubectl -n crowdsec get pods
```

```bash title="Command Output"
NAME READY STATUS RESTARTS AGE
crowdsec-agent-kf9fr 1/1 Running 0 34s
crowdsec-lapi-777c469947-jbk9q 1/1 Running 0 34s
```

### A word about source IPs

For CrowdSec to work in Kubernetes, it must see the real client IP. Otherwise
every request looks like it came from your ingress controller or load balancer.
Make sure the original IP is passed through (for example, proxy-protocol on
ingress, `externalTrafficPolicy: Local` on Services, or `real_ip_header` and
`set_real_ip_from` with NGINX). The exact steps depend on your stack, but the
goal is always the same: CrowdSec needs the real IP, not the proxy's.

### A word about Remediation Components

Installing the Security Engine (LAPI + agent) enables detections, but it does
not block anything by itself. To enforce decisions, install a remediation
component. In Kubernetes, remediation is currently done at the ingress level.

For now, we support:

* [Ingress Nginx](/bouncers/ingress-nginx.mdx)
* [Traefik Ingress](/bouncers/traefik.mdx)

Please note that the [Traefik Kubernetes Ingress (third-party
development)](https://plugins.traefik.io/plugins/6335346ca4caa9ddeffda116/crowdsec-bouncer-traefik-plugin))
is maintained outside CrowdSec.

In the crowdsec helm `values.yaml` file:

```yaml
lapi:
  env:
    - name: BOUNCER_KEY_<name>
      value: "<bouncer-key>"
```
example:
```yaml
lapi:
  env:
    - name: BOUNCER_KEY_traefik
      value: "mysecretkey12345"
```

To avoid having secrets stored in you `values.yaml` you can use secrets:
```bash
kubectl create secret generic crowdsec-keys \
  --from-literal=ENROLL_KEY=<enroll_key> \
  --from-literal=BOUNCER_KEY_ingress=<bouncer_key> \
  -n crowdsec
```

And use this in the values.yaml:
```yaml
lapi:
  env:
    - name: ENROLL_KEY
      valueFrom:
        secretKeyRef:
          name: crowdsec-keys
          key: ENROLL_KEY
      value: "<enroll-key>"
    - name: BOUNCER_KEY_traefik
      valueFrom:
        secretKeyRef:
          name: crowdsec-keys
          key: BOUNCER_KEY_traefik
      value: "<bouncer_key>"```
```

### A word about databases

By default, CrowdSec uses a SQLite database, which does not support replication.
In a Kubernetes environment, this limitation prevents the Local API from being
replicated.

For production deployments on Kubernetes, we recommend using a database engine
that can be deployed in a replicated or highly available way, such as MariaDB or
PostgreSQL. You can leverage existing operators to manage these databases:
* [mariadb operator](https://mariadb.com/resources/blog/get-started-with-mariadb-in-kubernetes-and-mariadb-operator/)
* [postgresql operator](https://github.com/cloudnative-pg/cloudnative-pg)

Configuration those databases is out of scope of this documentation.
<!-- We want to create blogpost where we do it -->

:::warning

SQLite may be suitable for testing or low traffic clusters, but it is not
recommended for Kubernetes production deployments. Besides the lack of
replication, SQLite can also become a performance bottleneck under heavy load.

:::

## Next steps

Great, you now have CrowdSec installed on your system. Within the [post
installation steps](/getting_started/next_steps.mdx) you will find the next
steps to configure and optimize your installation.
