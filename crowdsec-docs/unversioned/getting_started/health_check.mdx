---
id: health_check
title: CrowdSec Security Engine Setup Health-Check
pagination_prev: getting_started/intro
pagination_next: getting_started/next_steps
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';

<small className="health-check-version" style={{position: 'relative', top: '-30px'}}>Health Check Version: 0.2.0</small>

Welcome to the interactive Health-Check of your CrowdSec setup.  
We'll guide you through a series of tests to ensure that your Security Stack is fully functional and ready to protect your services:  
**Detecting**, **Threat Sharing** and **Remediating**.  
*This guide covers cases of protecting common services such as web servers (HTTP) and SSH.*   

We'll first test the final functionality of each component (top-down approach) before diving into detailed troubleshooting if issues arise.

This health check is divided into three main sections:
- [**üì° Detection**](#-detection-checks): Ensuring CrowdSec properly detects threats targeting your services.
- [**üîó Connectivity**](#-crowdsec-connectivity-checks): Verifying communication with the CrowdSec network to receive the community blocklist.
- [**üõ°Ô∏è Protection**](#-remediation-checks): Confirming that your bouncers automatically block threats detected by CrowdSec

* * *

## üì° Detection checks

### *Trigger CrowdSec's test scenarios*  

Let's use CrowdSec's built-in **dummy scenarios** (HTTP and Linux) to safely verify your Security Engine detects threats, without risking accidental self-blocking.

<details>
  <summary>üåê **HTTP** detection test</summary>
  
We'll trigger the dummy scenario `crowdsecurity/http-generic-test` by accessing a **probe path** on your web server.

1Ô∏è‚É£ Access your service URL with this path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/http-generic-test`

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>
    <CodeBlock className="language-bash">sudo cscli alerts list | grep crowdsecurity/http-generic-test</CodeBlock>
  </TabItem>
  <TabItem value="docker" label="Docker">
    <CodeBlock className="language-bash">docker exec crowdsec cscli alerts list | grep crowdsecurity/http-generic-test</CodeBlock>
  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">
    <CodeBlock className="language-bash">kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli alerts list | grep crowdsecurity/http-generic-test</CodeBlock>
  </TabItem>
</Tabs>

**Notes:**  
- Requests from private IP addresses won't trigger alerts (private IPs are whitelisted by default).
  - You can also test via a browser if easier, especially from another device.
- This scenario can be triggered again only after a 5-minutes delay.
</details>

<details>
    <summary>üîê **SSH** detection test</summary>

We'll trigger the dummy scenario `crowdsecurity/ssh-generic-test` by attempting an SSH login with a specific username.

1Ô∏è‚É£ Attempt SSH login using this username: `crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`.
<CodeBlock className="language-bash">ssh crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl@\<your-server-ip\></CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/ssh-generic-test`

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>
    <CodeBlock className="language-bash">sudo cscli alerts list | grep crowdsecurity/ssh-generic-test</CodeBlock>
  </TabItem>
  <TabItem value="docker" label="Docker">
    <CodeBlock className="language-bash">docker exec crowdsec cscli alerts list | grep crowdsecurity/ssh-generic-test</CodeBlock>
  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">
    It's uncommon to have to deal with this scenario in Kubernetes, but if you do:
    <CodeBlock className="language-bash">kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli alerts list | grep crowdsecurity/ssh-generic-test</CodeBlock>
  </TabItem>
</Tabs>

**Notes:** 
- This scenario can only be triggered again after a 5-minutes delay. 
</details>

<details>
    <summary>üõ°Ô∏è **AppSec** detection test - CrowdSec WAF </summary>

If you've enabled an AppSec-capable bouncer with CrowdSec WAF with the [Virtual Patching collection](https://app.crowdsec.net/hub/author/crowdsecurity/collections/appsec-virtual-patching), you can trigger the `crowdsecurity/appsec-generic-test` dummy scenario.  
It would have triggered along with the HTTP detection test, but it is worth mentioning here as well.  

We'll trigger the dummy scenario `crowdsecurity/appsec-generic-test` by accessing a **probe path** on your web server.

1Ô∏è‚É£ Access your service URL with this path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/appsec-generic-test`

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>
    <CodeBlock className="language-bash">sudo cscli alerts list | grep crowdsecurity/appsec-generic-test</CodeBlock>
  </TabItem>
  <TabItem value="docker" label="Docker">
    <CodeBlock className="language-bash">docker exec crowdsec cscli alerts list | grep crowdsecurity/appsec-generic-test</CodeBlock>
  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">
    <CodeBlock className="language-bash">kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli alerts list | grep crowdsecurity/appsec-generic-test</CodeBlock>
  </TabItem>
</Tabs>

**Notes:**
- This scenario can only be triggered again after a 1-minute delay. 
</details>

* * *

### Were all the tests successful ?

Were all the tests related to your setup successful? 
üëç If so, you can proceed to the next phase of the health check: [**Connectivity checks**](#-crowdsec-connectivity-checks).  

üõ†Ô∏è If not, check the troubleshooting section below.

<details>
    <summary>üêû **Detection Troubleshooting**</summary>

  **No alert triggered? Let's find out why.**   

  If you installed CrowdSec on the same **host** as the service you're protecting, it should have auto-detected it and installed the right collections of parsers and scenarios.
  However, if you're using *custom log paths*, *unusual log formats*, or running in *Docker/Kubernetes*, you might need to configure some things manually.  
  
 **This section will help you pinpoint the issue and walk you through how to fix it.**  

  <details>
      <summary>üìÑ Are your logs being properly read and parsed?</summary>

  CrowdSec needs to know what logs to read and how to interpret them.  
  This is handled by the acquisition configuration (log sources) and parsing (how to read them).
  Multiple log sources can be defined in the acquisition(s) configuration files and they support diverse datasources (files, syslog, etc.).
  For more details you can refer to the [datasources documentation](https://doc.crowdsec.net/docs/next/log_processor/data_sources/intro).  

  We'll look at the security engine **metrics** to see if logs are **being read** and if what's read is **parsed correctly**.
  We'll do that using the `cscli metrics` command:

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>
    <CodeBlock className="language-bash">sudo cscli metrics show acquisition parsers</CodeBlock>
  </TabItem>
  <TabItem value="docker" label="Docker">
    <CodeBlock className="language-bash">docker exec crowdsec cscli metrics show acquisition parsers</CodeBlock>
  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">
    <CodeBlock className="language-bash">
     for i in $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=agent -o name); do kubectl exec -n crowdsec -it $i -- cscli metrics show acquisition parsers; done
    </CodeBlock>
  </TabItem>
</Tabs>

  Under **Acquisition Metrics** you should see:
  - The source name of the log files or streams that have been read and the number of lines read and parsed for each of them.
    - If you don't see any sources or some you have configured are missing, it means that the acquisition configuration is not properly set up. 
    - A non zero number of "Lines parsed" is expected for each source, proving that the appropriate parser was found and used.
  
  Under The **Parsers Metrics** you have the details of the parsers used.

  üö® If this check fails, don‚Äôt worry -- the results will point you to the right area to troubleshoot:  
  
  :::warning
      üêû If this command fails entirely, go to the [**CrowdSec Service Troubleshooting section**](#troubleshooting_service)
  :::
  :::warning
      üêû If your acquisition sources don't appear, check the [**Acquisition Troubleshooting section**](#troubleshooting_acquisition)
  :::
  :::warning
    üêû If parsing fails, check the [**Collection Troubleshooting section****](#troubleshooting_collection)
  :::

  </details>

  <details id="troubleshooting_acquisition">
      <summary>üì• Acquisition Troubleshooting -- Are your logs properly declared as datasources</summary>

  CrowdSec needs to know where to **read your logs**. The configuration varies by deployment method:

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>

  The **acquisition configuration** is usually found in `acquis.yaml` or in files under `acquis.d/` inside the CrowdSec config directory.
  On Debian-like OS it is typically located in `/etc/crowdsec/`.

  **To troubleshoot:**
  - The detailed doc about the acquisition configuration can be found [here](https://doc.crowdsec.net/docs/next/log_processor/acquisition/intro).
  - Check your acquisition files exist and that the datasources are properly setup.
  - üí° Hint:
    - The hub page of the collection you installed provides an example of the acquisition configuration file to create.
    - For example:
      - The [NGINX collection hub page ‚ÜóÔ∏è](https://app.crowdsec.net/hub/author/crowdsecurity/collections/nginx)
      - Or the [SSHD collection hub page ‚ÜóÔ∏è](https://app.crowdsec.net/hub/author/crowdsecurity/collections/sshd) (that is contained in the Linux Collection).
  - Make sure that the **type** declared matches the **parser** expected to be used: nginx, apache, syslog, etc.

  </TabItem>
  <TabItem value="docker" label="Docker">

  In Docker, logs must be accessible to the container through volumes.

  **Common issues:**
  - **Missing volume mounts** & **Shared log volumes**: Ensure log directories are mounted in your container and available in multi-container setup.  
  Example if your service logs are in `/var/log` on the host or in a `logs` shared volume:
    ```yaml
    volumes:
      - /var/log:/var/log:ro  # Example for mounting logs as read-only
      - logs:/logs:ro   # Example for shared log volume between containers
    ```
  - **Acquisition configuration**: Your `acquis.yaml` or `acquis.d/*.yaml` files should reference paths inside the container.
  - **Log file permissions**: CrowdSec container user must have read access to log files.

  **To check your acquisition config:**
  ```bash
  docker exec crowdsec cat /etc/crowdsec/acquis.yaml # or acquis.d/*.yaml
  ```

  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">

  In Kubernetes, CrowdSec reads logs from `/var/log/containers` which is mounted into pods by the helm chart.

  **Configuration is done in your Helm values file:**
  ```yaml
  agent:
    acquisition:
      - namespace: your-namespace
        podName: your-pod-*
        program: nginx  # Reference used by the FILTER function of your installed parsers
  ```

  **Common issues:**
  - **Wrong namespace or pod names**: Verify pods exist with `kubectl get pods -n <namespace>`
  - **Incorrect program name**: The `program` field must match the FILTER of your installed parser (nginx, traefik, apache, etc.)
  - **Container runtime mismatch**: Set `container_runtime: containerd` or `container_runtime: docker` in values.yaml

  **Note:** Unlike standalone deployments, you use `program:` instead of `type:` in Kubernetes acquisitions.

  </TabItem>
</Tabs>

  </details>

  <details id="troubleshooting_collection">
      <summary>üì¶ Collection Troubleshooting -- Are the right parsers and scenarios installed?</summary>

  CrowdSec, via its [**Hub** ‚ÜóÔ∏è](https://app.crowdsec.net/hub/collections) uses collections to package correct parsers and detection scenarios for your services.

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>

  On regular **host** installations, CrowdSec usually detects your services (like nginx or ssh) and installs the appropriate collections automatically.

  **üîç To check what's currently installed:**
  ```bash
  sudo cscli collections list
  ```

  You can also list individual parsers and scenarios with:
  ```bash
  sudo cscli parsers list
  sudo cscli scenarios list
  ```

  - Look for entries related to your service (e.g., nginx, apache, ssh).
  - If they're listed, the right collection is likely installed.

  **üì• Install missing collections:**
  1. Visit the [CrowdSec Hub ‚ÜóÔ∏è](https://hub.crowdsec.net/) and search for a collection matching your service
  2. Install with:
     ```bash
     sudo cscli collections install crowdsecurity/nginx
     sudo systemctl reload crowdsec
     ```

  </TabItem>
  <TabItem value="docker" label="Docker">

  In Docker, collections must be installed via the `COLLECTIONS` environment variable.

  **üîç To check what's currently installed:**
  ```bash
  docker exec crowdsec cscli collections list
  ```

  **üì• Install collections:**

  ```yaml
  environment:
    COLLECTIONS: "crowdsecurity/nginx crowdsecurity/linux"
  ```
  Then **restart the container**.

  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">

  In Kubernetes, collections must be specified in your Helm values file.

  **üîç To check what's currently installed:**
  ```bash
  for i in $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=agent -o name); do kubectl exec -n crowdsec -it $i -- cscli collections list; done
  ```

  **üì• Install collections:**

  Add to your `values.yaml`:
  ```yaml
  agent:
    env:
      - name: COLLECTIONS
        value: "crowdsecurity/traefik crowdsecurity/nginx"
  ```

  Then upgrade your Helm release:
  ```bash
  helm upgrade crowdsec crowdsec/crowdsec -n crowdsec -f values.yaml
  ```

  </TabItem>
</Tabs>

  **‚ö†Ô∏è Log format mismatch:**
  - If your logs don't follow the expected format (e.g., they've been customized), CrowdSec might not parse them properly.
  - You can find more information on how to create your own parsers in the [CrowdSec documentation](https://doc.crowdsec.net/docs/next/log_processor/parsers/format).

  </details>

  <details id="troubleshooting_service">
      <summary>‚öôÔ∏è CrowdSec Service Troubleshooting -- is the CrowdSec service running?</summary>

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>

  Let's check if the CrowdSec service is active:
  ```bash
  sudo systemctl status crowdsec
  ```
  - ‚òëÔ∏è You should see: "**active (running)**"

  **If the service is not running:**
  ```bash
  sudo systemctl start crowdsec
  sudo systemctl enable crowdsec  # Ensure it starts on boot
  ```

  **Check logs for errors:**
  ```bash
  # Start by checking crowdsec logs
  less /var/log/crowdsec.log

  # Eventually check systemd journal logs
  sudo journalctl -u crowdsec -n 50
  ```

  **Common issues:**
  - Misconfiguration in `/etc/crowdsec/config.yaml`
  - Port conflicts (default: 8080 for LAPI, 6060 for metrics)
  - Insufficient permissions to access log files
  - Acquisition files format errors

  </TabItem>
  <TabItem value="docker" label="Docker">

  Check if the container is running:
  ```bash
  docker ps | grep crowdsec
  ```

  **If not running, check container logs:**
  ```bash
  docker logs crowdsec
  ```

  **Make sure your container starts without error**

  **Common issues:**
  - **Volume mount errors**: Ensure `/etc/crowdsec/` and `/var/lib/crowdsec/data/` are properly mounted
  - **Missing data volume**: Since v1.7.0, `/var/lib/crowdsec/data/` must be persisted
  - **Port conflicts**: Check if 8080 is available on host
  - **Log access**: Ensure log volumes are correctly mounted and readable
  - **Environment variables**: Verify `COLLECTIONS` and other env vars are set correctly

  **Check container status:**
  ```bash
  docker inspect crowdsec
  ```

  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">

  Check if pods are running:
  ```bash
  kubectl get pods -n crowdsec
  ```

  You should see LAPI and agent pods in `Running` status.

  **Check pod logs:**
  ```bash
  # LAPI logs
  kubectl logs -n crowdsec -l k8s-app=crowdsec -l type=lapi

  # Agent logs
  kubectl logs -n crowdsec -l k8s-app=crowdsec -l type=agent
  ```

  **Describe pod for more details:**
  ```bash
  kubectl describe pod -n crowdsec <pod-name>
  ```

  **Common issues:**
  - **ConfigMap errors**: Verify configuration is valid
    ```bash
    kubectl get configmap -n crowdsec
    ```
  - **Resource limits**: Check if pods have sufficient CPU/memory
  - **Network policies**: Ensure pods can communicate with each other
  - **PVC issues**: If using persistent volumes, ensure PVCs are bound
    ```bash
    kubectl get pvc -n crowdsec
    ```
  - **Image pull errors**: Check if the CrowdSec image is accessible, could happen if you have registry conflicts

  **Upgrade your Helm**
  ```bash
  helm upgrade crowdsec crowdsec/crowdsec -n crowdsec -f values.yaml
  ```

  </TabItem>
</Tabs>

  </details>
</details>

## üîå CrowdSec Connectivity checks

### Is your Security Engine receiving community blocklists?

Let‚Äôs confirm that your Security Engine can communicate with the CrowdSec Central API (CAPI).
This connection allows you to:
- Receive **Community Blocklists** -- curated IPs flagged as malicious by the global CrowdSec network.
- Receive additional Blocklists of your choice among the ones available to you.
- Contribute back -- sharing detected Malicious IPs triggering installed scenarios.

<details>
  <summary>üîå CrowdSec Central API connectivity</summary>

  The most direct way to verify connectivity is to see if your instance has already received decisions from the Community Blocklist.

  1Ô∏è‚É£ List decisions coming from CAPI

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>
    <CodeBlock className="language-bash">sudo cscli decisions list --origin CAPI</CodeBlock>
  </TabItem>
  <TabItem value="docker" label="Docker">
    <CodeBlock className="language-bash">docker exec crowdsec cscli decisions list --origin CAPI</CodeBlock>
  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">
    <CodeBlock className="language-bash">kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli decisions list --origin CAPI</CodeBlock>
  </TabItem>
</Tabs>

  ‚òëÔ∏è If you see decisions, you're connected and receiving threat intel.

  **Notes:**
  - On a fresh install, it might take a few minutes before any decisions appear.
  - Restarting the CrowdSec service will force it to perform a first pull.
</details>

### Were all the tests successful ?

Were all the tests related to your setup successful? 
üëç If so, you can proceed to the next phase of the health check: [Remediation Check](#-remediation-checks)

üõ†Ô∏è If not, check the troubleshooting section below.

<details>
  <summary>üêû Connectivity Troubleshooting</summary>

  Let's verify your CAPI connection step-by-step.

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>

  **Check CAPI status:**
  ```bash
  sudo cscli capi status
  ```

  **Should show:**
  - `INFO You can successfully interact with Central API (CAPI)`
  - Information about the connectivity config file path
  - Enrollment status with CrowdSec Console

  **Common issues:**
  - **Missing credentials**: If `online_api_credentials.yaml` is missing:
    ```bash
    sudo cscli capi register
    sudo systemctl reload crowdsec
    ```
  - **Firewall blocking**: Ensure outbound network access (API endpoints, blocklists, etc.). See [Network Management](https://docs.crowdsec.net/docs/next/configuration/network_management/) for full requirements
  - **DNS issues**: Verify DNS resolution works:
    ```bash
    nslookup api.crowdsec.net
    ```
  - **Proxy configuration**: If behind a proxy, configure in `/etc/crowdsec/config.yaml`

  </TabItem>
  <TabItem value="docker" label="Docker">

  **Check CAPI status:**
  ```bash
  docker exec crowdsec cscli capi status
  ```

  **Should show:**
  - `INFO You can successfully interact with Central API (CAPI)`

  **Common issues:**
  - **No internet from container**: Ensure container can reach external networks
    ```bash
    docker exec crowdsec ping -c 3 api.crowdsec.net
    ```
  - **Missing credentials**: Register if credentials are missing:
    ```bash
    docker exec crowdsec cscli capi register
    docker restart crowdsec
    ```
  - **Volume not persisted**: Ensure `/etc/crowdsec/` volume persists the credentials file
  - **Network mode**: If using custom networks, verify routing and DNS
  - **Proxy issues**: Set `HTTP_PROXY` and `HTTPS_PROXY` environment variables if needed

  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">

  **Check CAPI status:**
  ```bash
  kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli capi status
  ```

  **Should show:**
  - `INFO You can successfully interact with Central API (CAPI)`
  - Enrollment information if configured

  **Common issues:**
  - **No external connectivity**: Test from pod:
    ```bash
    kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- ping -c 3 api.crowdsec.net
    ```
  - **NetworkPolicy blocking**: Check if NetworkPolicies allow egress to api.crowdsec.net
  - **DNS issues**: Verify CoreDNS is working correctly
  - **Proxy configuration**: Configure proxy via environment variables in values.yaml:
    ```yaml
    lapi:
      env:
        - name: HTTP_PROXY
          value: "http://proxy:8080"
        - name: HTTPS_PROXY
          value: "http://proxy:8080"
    ```
  - **PVC not bound**: If credentials aren't persisting, check PVC status
  - **Enrollment key**: If using console enrollment, verify `ENROLL_KEY` is set correctly in values.yaml

  </TabItem>
</Tabs>

</details>

## ‚úãüèª Remediation checks

### *Validate Blocks or Captchas* 

Now that detection and connectivity are working, let‚Äôs verify that your bouncers are correctly applying remediation on malicious IPs.  

**Prerequisite:**  
To apply remediation with CrowdSec, you‚Äôll need a bouncer ‚Äî available for firewalls, web servers, reverse proxies, CDNs, cloud WAFs, edge appliances, [and more](https://doc.crowdsec.net/u/bouncers/intro).  

<details>
  <summary>‚úãüèª Bouncer Remediation test</summary>

This test involves manually creating a **decision** against a public IP of one of your devices for a very short period (1 minute).  

:::danger 
BE CAREFUL -- Risk of Self-Lockout  
This procedure will temporarily block your access to the services protected by your bouncer.  
Make sure to properly follow the instructions to set the TTL to a low expiration time (1 minute). 
OR do it from a device with a different public IP address than the client you're using to setup CrowdSec.
:::

1Ô∏è‚É£ Find your public IP:
<CodeBlock className="language-bash">curl api.ipify.org</CodeBlock>

2Ô∏è‚É£ Add a ban decision for your IP (valid for 1 minute):

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>
    <CodeBlock className="language-bash">sudo cscli decisions add --ip \<your-public-ip\> --duration 1m --reason "CrowdSec remediation test"</CodeBlock>
  </TabItem>
  <TabItem value="docker" label="Docker">
    <CodeBlock className="language-bash">docker exec crowdsec cscli decisions add --ip \<your-public-ip\> --duration 1m --reason "CrowdSec remediation test"</CodeBlock>
  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">
    <CodeBlock className="language-bash">kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli decisions add --ip \<your-public-ip\> --duration 1m --reason "CrowdSec remediation test"</CodeBlock>
  </TabItem>
</Tabs>

‚è≥ *Wait a few seconds to ensure the decision is processed by the bouncer.*  
3Ô∏è‚É£ Try accessing your service (e.g. website, API). from the same public IP address.
  ‚û°Ô∏è You should be blocked by the bouncer. returning a forbidden response (HTTP 403) or a captcha challenge.

4Ô∏è‚É£ Wait for 1 minute, then check the decisions list to see if the decision has been removed

</details>

### Were all the tests successful ?

If you were successfully blocked, congratulations! Your remediation setup is working correctly. üéâ  

You might want to continue to the next recommended steps:
- Enroll your Security Engine to the [CrowdSec Console](/u/getting_started/post_installation/console/)
- Then subscribe to more blocklists to benefit from additional proactive prevention

<details>
    <summary>üêû **Remediation Troubleshooting**</summary>

  Before diving into troubleshooting, remember that a remediation components (AKA **bouncer**) is a separate component that connects to the Security Engine and regularly pulls decisions (like bans or captchas) to apply them at its level (firewall, web server, etc.). If remediation isn‚Äôt working, it‚Äôs often due to issues in this communication loop.  
  You can find more information about bouncers in the [Bouncers documentation](https://doc.crowdsec.net/docs/next/bouncers/intro).
  The full list of available bouncers is available on the [CrowdSec Hub ‚ÜóÔ∏è](https://app.crowdsec.net/hub/remediation-components).

  <details>
    <summary>Is your Bouncer Installed and Connected to your Security engine</summary>

<Tabs groupId="deployment">
  <TabItem value="host" label="On Host" default>

  **Check bouncers linked to your Security Engine:**
  ```bash
  sudo cscli bouncers list
  ```

  **You should see:**
  - The bouncer name
  - A ‚úì in the valid column indicating proper registration
  - A recent `Last API pull` timestamp

  **Common issues:**
  - **Bouncer not valid or not pulling**: Check authentication in bouncer config file
  - **Bouncer not listed**: Register it:
    ```bash
    sudo cscli bouncers add my-bouncer-name
    ```
    Copy the token and add it to your bouncer's configuration, then restart the bouncer service.

  - **Bouncer on different machine**: Ensure it can reach the LAPI endpoint (default: `http://crowdsec-server:8080`)
  - **Firewall blocking**: Verify port 8080 is accessible from bouncer machine

  </TabItem>
  <TabItem value="docker" label="Docker">

  **Check bouncers linked to your Security Engine:**
  ```bash
  docker exec crowdsec cscli bouncers list
  ```

  **Common issues:**
  - **Bouncer in separate container**: Ensure containers are on the same Docker network
  - **LAPI URL**: Bouncer config should point to `http://crowdsec:8080` (using container name)
  - **Register bouncer**: You can pre-create bouncer keys using environment variables:
    ```yaml
    environment:
      BOUNCER_KEY_mybouncer: "my-secret-api-key"
    ```
  - **Network connectivity**: Test from bouncer container:
    ```bash
    docker exec my-bouncer ping crowdsec
    ```

  </TabItem>
  <TabItem value="kubernetes" label="Kubernetes">

  **Check bouncers linked to your Security Engine:**
  ```bash
  kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli bouncers list
  ```

  **Common issues:**
  - **Service discovery**: Bouncer should connect to `http://crowdsec-lapi.crowdsec.svc.cluster.local:8080`
  - **Register bouncer**: For Kubernetes remediation components (Ingress-Nginx, Traefik):
    ```bash
    # Generate API key
    kubectl exec -n crowdsec -it $(kubectl get pods -n crowdsec -l k8s-app=crowdsec -l type=lapi -o name) -- cscli bouncers add k8s-bouncer

    # Or pre-configure in values.yaml
    lapi:
      env:
        - name: BOUNCER_KEY_k8s
          value: "your-api-key-here"
    ```
  - **Network policies**: Ensure bouncer namespace can reach crowdsec namespace
  - **Service accessibility**: Verify the crowdsec-lapi service is accessible:
    ```bash
    kubectl get svc -n crowdsec crowdsec-lapi
    ```

  **For Ingress Nginx bouncer:**
  - Ensure the bouncer has the correct LAPI URL in its ConfigMap
  - Check bouncer logs for connection errors:
    ```bash
    kubectl logs -n ingress-nginx -l app.kubernetes.io/component=controller
    ```

  </TabItem>
</Tabs>

  </details>
</details>

## üí¨ Your feedback is important!

Help us improve this health check guide!  
Give us feedback via this form: [üìù Health Check Feedback Form ‚ÜóÔ∏è](https://forms.gle/DJboC7oisjmA8qt78)  

[üì® Open an issue on GitHub ‚ÜóÔ∏è](https://github.com/crowdsecurity/crowdsec-docs/issues/new) or  
üó£Ô∏è Join the conversation on [Discord ‚ÜóÔ∏è](https://discord.gg/wGN7ShmEE8)