---
id: health_check
title: CrowdSec Security Engine Setup Health-Check
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import { CheckboxProvider, InteractiveCheckbox } from '@site/src/components/InteractiveCheckbox.js';
import HierarchicalList from '@site/src/components/HierarchicalList.js';

<small className="health-check-version" style="position: relative;top: -32px;">Health Check Version: 0.1.0</small>

Welcome to the interactive Health-Check of your CrowdSec setup.  
We'll guide you through a series of tests to ensure that your Security Stack is fully functional and ready to protect your services:  
**Detecting**, **Threat Sharing** and **Remediating**.  
*This guide covers cases of protecting common services such as web servers (HTTP) and SSH.*   

We'll first test the final functionality of each component (top-down approach) before diving into detailed troubleshooting if issues arise.

This health check is divided into three main sections:
- [**üì° Detection**](#-detection-checks): Ensuring CrowdSec properly detects threats targeting your services.
- [**üîó Connectivity**](#-crowdsec-connectivity-checks): Verifying communication with the CrowdSec network to receive the community blocklist.
- [**üõ°Ô∏è Protection**](#-remediation-checks): Confirming that your bouncers automatically block threats detected by CrowdSec

* * *

## üì° Detection checks

### *Trigger CrowdSec's test scenarios*  

Let's use CrowdSec's built-in **dummy scenarios** (HTTP and Linux) to safely verify your Security Engine detects threats, without risking accidental self-blocking.

<details>
  <summary>üåê **HTTP** detection test</summary>
  
We'll trigger the dummy scenario `crowdsecurity/http-generic-test` by accessing a **probe path** on your web server.

1Ô∏è‚É£ Access your service URL with this path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/http-generic-test`
<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/http-generic-test</CodeBlock>

**Notes:**  
- Requests from private IP addresses won't trigger alerts (private IPs are whitelisted by default).
  - You can also test via a browser if easier, especially from another device.
- This scenario can be triggered again only after a 5-minutes delay.
</details>

<details>
    <summary>üîê **SSH** detection test</summary>

We'll trigger the dummy scenario `crowdsecurity/ssh-generic-test` by attempting an SSH login with a specific username.

1Ô∏è‚É£ Attempt SSH login using this username: `crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`.
<CodeBlock className="language-bash">ssh crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl@\<your-server-ip\></CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/ssh-generic-test`
<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/ssh-generic-test</CodeBlock>

**Notes:** 
- This scenario can only be triggered again after a 5-minutes delay. 
</details>

<details>
    <summary>üõ°Ô∏è **AppSec** detection test - CrowdSec WAF </summary>

If you've enabled an AppSec-capable bouncer with CrowdSec WAF, you can trigger the `crowdsecurity/appsec-generic-test` dummy scenario.  
It would have triggered along with the HTTP detection test, but it is worth mentioning here as well.  

Here is how to trigger the `crowdsecurity/appsec-generic-test` dummy scenario by calling a *probe path* on your web server.

We'll trigger the dummy scenario `crowdsecurity/appsec-generic-test` by accessing a **probe path** on your web server.

1Ô∏è‚É£ Access your service URL with this path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/appsec-generic-test`
<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/appsec-generic-test</CodeBlock>

**Notes:**
- This scenario can only be triggered again after a 1-minute delay. 
</details>

* * *

### Were all the tests successful ?

Were all the tests related to your setup successful? 
üëç If so, you can proceed to the next phase of the health check: [**Connectivity checks**](#-crowdsec-connectivity-checks).  

üõ†Ô∏è If not, check the troubleshooting section below.

<details>
    <summary>üêû **Detection Troubleshooting**</summary>

  **No alert triggered? Let's find out why.**   

  If you installed CrowdSec on the same **host** as the service you're protecting, it should have auto-detected it and installed the right collections of parsers and scenarios.
  However, if you're using *custom log paths*, *unusual log formats*, or running in *Docker/Kubernetes*, you might need to configure some things manually.  
  
 **This section will help you pinpoint the issue and walk you through how to fix it.**  

  <details>
      <summary>Are your logs being properly read and parsed?</summary>

  CrowdSec needs to know what logs to read and how to interpret them.  
  This is handled by the acquisition configuration (log sources) and parsing (how to read them).
  Multiple log sources can be defined in the acquisition(s) configuration files and they support diverse datasources (files, syslog, etc.).
  For more details you can refer to the [datasources documentation](https://doc.crowdsec.net/docs/next/log_processor/data_sources/intro).  

  We'll look at the security engine **metrics** to see if logs are **being read** and if what's read is **parsed correctly**.  
  We'll do that using the `cscli metrics` command:
  <CodeBlock className="language-bash">sudo cscli metrics show acquisition parsers</CodeBlock>

  Under **Acquisition Metrics** you should see:
  - The source name of the log files or streams that have been read and the number of lines read and parsed for each of them.
    - If you don't see any sources or some you have configured are missing, it means that the acquisition configuration is not properly set up. 
    - A non zero number of "Lines parsed" is expected for each source, proving that the appropriate parser was found and used.
  
  Under The **Parsers Metrics** you have the details of the parsers used.

  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üêû If this command fails, check the [**CrowdSec Service Troubleshooting section**](#troubleshooting_service)
  </div>
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üêû If you don't see the log names supposed to be parsed, check the [**Acquisition Troubleshooting section**](#troubleshooting_acquisition)
  </div>
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üêû If you don't see parsed lines, check the [**Collection Troubleshooting section****](#troubleshooting_collection)
  </div>

  </details>

  <details id="troubleshooting_acquisition">
      <summary>Acquisition Troubleshooting: are your logs properly declared as datasources</summary>

  Your acquisition configuration is located in the `crowdsec` directory under `acquis.yaml` or `acquis.d/anyName.yaml`.  
  The CrowdSec directory changes depending on your OS and installation method, for example, on Debian like OS it is usually located in `/etc/crowdsec/`.  

  You may want to check your current acquisition configuration or [add a new acquisition file](https://doc.crowdsec.net/u/getting_started/post_installation/acquisition_new).
  - Check that the datasource is properly setup: file path or correct port for syslog server...
  - Ensure that the type declared matches the parser expected to be used: nginx, apache, syslog, etc.
  - for more information, check the [documentation for the various datasources](https://doc.crowdsec.net/docs/next/log_processor/data_sources/intro)
  </details>

  <details id="troubleshooting_collection">
      <summary>Collection Troubleshooting: are the parsers and scenarios installed?</summary>

  #### Collection installation
  - On host installations your existing service should have been detected and appropriate collections (containing parsers and scenarios) installed automatically.
  - How ever on other kind of installations, or in case of failed detection, you may need to install the collections manually.

  Check the installed collections with the command:
  <CodeBlock className="language-bash">sudo cscli collections list</CodeBlock>
  You can also list individual parsers and scenarios with:
  <CodeBlock className="language-bash">sudo cscli parsers list</CodeBlock>
  <CodeBlock className="language-bash">sudo cscli scenarios list</CodeBlock>
  - If you see the parsers and scenarios related to your service, then you're good to go.

  - To install new collection, check the [CrowdSec Hub](https://hub.crowdsec.net/) for a collection named after your service (e.g., [nginx](https://app.crowdsec.net/hub/author/crowdsecurity/collections/nginx), [apache](https://app.crowdsec.net/hub/author/crowdsecurity/collections/apache), [linux](https://app.crowdsec.net/hub/author/crowdsecurity/collections/linux), etc.).
  - If you find the collection, install it using the command shown on the hub page and follow the instructions provided for the acquisition file.

  #### Log format mismatch
  - If your logs are in a custom format, you may need to create your own parsers or modify the existing ones to match your log format.
  - You can find more information on how to create your own parsers in the [CrowdSec documentation](https://doc.crowdsec.net/docs/next/log_processor/parsers/format).

  </details>

  <details id="troubleshooting_service">
      <summary>CrowdSec Service Troubleshooting: is the CrowdSec service running?</summary>
  Make sure the CrowdSec service is running properly. You can check the status of the service with the following command:
  <CodeBlock className="language-bash">sudo systemctl status crowdsec</CodeBlock> 
  - You should see the service status as "active (running)".

  If the service is not running, you can start it with the following command:
  <CodeBlock className="language-bash">sudo systemctl start crowdsec</CodeBlock>

  If the service fails to start, you can check the logs for more information:
  <CodeBlock className="language-bash">sudo journalctl -u crowdsec</CodeBlock>

  Reasons for the service not running can include:
  - Misconfiguration in the `config.yaml` file.
    - Port conflicts with other services. By default, CrowdSec uses port 8080 for the Local API (LAPI) and port 6060 for the Local API metrics.
    - The port configuration can be setup in `config.yaml` file or by setting the environment variables depending on your implementation
  - Insufficient permissions to access the log files or directories.
  - Acquisition files format errors.

  </details>
</details>

## üîå CrowdSec Connectivity checks

### *List the community-blocked IPs*  

Let's check that your Security Engine can communicate with the CrowdSec Central API (CAPI). This connection is essential for participating in the community and protecting your setup with the collective intelligence of the network.  
The CAPI allows your instance to receive a curated blocklist of malicious IP addresses identified and verified by the entire CrowdSec network. This proactive defense, known as the Community Blocklist, protects you from aggressors before they even target your services. It also allows your Security Engine to report the malicious IPs it detects, contributing to the strength of the community.

<details>
  <summary>üîå CrowdSec Central API connectivity</summary>

  The most direct way to verify connectivity is to see if your instance has already received decisions from the community blocklist.

  1Ô∏è‚É£ List decisions coming from CAPI
  
  <CodeBlock className="language-bash">sudo cscli decisions list --origin CAPI </CodeBlock>

  2Ô∏è‚É£ If you see decisions listed, it means your Security Engine is successfully connected to the CAPI and receiving decisions.
</details>

### Were all the tests successful ?

<details>
    <summary>üêû Connectivity Troubleshooting</summary>

  Check CAPI status with the command:
  <CodeBlock className="language-bash">sudo cscli capi status</CodeBlock>
  - Should show: "You can successfully interact with Central API (CAPI)"
  - If this test fail, try to enrol to the console to check what's going on.

  Other common issues that can prevent your Security Engine from connecting to the CAPI include:
  - Check that the online api credentials `online_api_credentials.yaml` exist in your crowdsec config directory
    - If they don't exist, you can create them by running the command:
      <CodeBlock className="language-bash">sudo cscli capi register</CodeBlock>
  - Check that the `crowdsec` service is running and properly configured to connect to the CAPI.
  - Firewall rules blocking outbound connections to the CrowdSec Central API.
  - DNS resolution issues.
  - Proxy server configuration.
  - Connectivity issues within Docker containers.

</details>

## ‚úãüèª Remediation checks

### *Validate Blocks or Captchas* 

Now that we've confirmed that the Security Engine can detect threats, let's verify that your bouncers are correctly applying decisions and blocking malicious IPs.

::info A note on future improvements
In the future, this health-check will include an option to trigger a remote test from the CrowdSec Console, which will safely probe your defenses from an external IP.
For now, we will perform a manual test by temporarily banning your own IP address. Please read the following warning carefully before proceeding.
:::

<details>
  <summary>‚úãüèª Bouncer Remediation test</summary>

This test involves manually creating a ban decision against your own public IP address for a very short period (1 minute).  

::danger BE CAREFUL: Risk of Self-Lockout
This procedure will temporarily block your access to the services protected by your bouncer.  
Make sure to properly set the TTL to a low expiration time (1 minute). OR do it from a device with a different public IP address than the client you're using to setup CrowdSec.
::

1Ô∏è‚É£ Find out you public address by using the following command:
<CodeBlock className="language-bash">curl api.ipify.org</CodeBlock>
or
<CodeBlock className="language-bash">curl curl ipinfo.io/ip</CodeBlock>

2Ô∏è‚É£ Create a ban decision for your public IP address with a TTL of 1 minute:
<CodeBlock className="language-bash">sudo cscli decisions add ban --ip \<your-public-ip\> --duration 1m --reason "CrowdSec remediation test"</CodeBlock>

3Ô∏è‚É£ Try to access your service (website, api ...) from the same public IP address. \> You should be blocked by the bouncer.

4Ô∏è‚É£ Wait for 1 minute, then check the decisions list to see if the decision has been removed

</details>

### Were all the tests successful ?

If you were successfully blocked, congratulations! Your remediation setup is working correctly. üéâ  

You might want to continue to the next recommended steps:
- Enroll your Security Engine to the [CrowdSec Console](/u/getting_started/post_installation/console/)
- Then subscribe to more blocklists to benefit from additionnl proactive prevention

<details>
    <summary>üêû **Remediation Troubleshooting**</summary>

  ...

  <details>
      <summary>Bouncer Configuration Troubleshooting</summary>
      
  *   Verifying that the bouncer is registered and active.
  *   Checking bouncer logs for errors.
  *   Troubleshooting communication issues between the bouncer and the CrowdSec LAPI.
  *   Firewall configuration for the bouncer.
  *   Specific troubleshooting steps for common bouncers (firewall-bouncer, nginx-bouncer, etc.).)

  </details>

  <details>
      <summary>Profile Troubleshooting</summary>

  *   Verifying profile configuration.
  *   Troubleshooting errors related to profile application.
  *   Understanding the impact of profiles on detection and remediation.)

  </details>
</details>

## Your feedback is important!

If you have any suggestions or improvements for this health check, please let us know by opening an issue on our [GitHub repository](https://github.com/crowdsecurity/crowdsec-docs/issues/new) or on our [discord](https://discord.gg/wGN7ShmEE8)