---
id: health_check
title: CrowdSec Security Engine Setup Health-Check
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import { CheckboxProvider, InteractiveCheckbox } from '@site/src/components/InteractiveCheckbox.js';
import HierarchicalList from '@site/src/components/HierarchicalList.js';

<small className="health-check-version">Health Check Version: 0.1.0</small>

Welcome to the interactive health check of your CrowdSec setup.  
We'll guide you through a series of tests to ensure that your Security Stack is fully functional and ready to protect your services: **Detecting**, **Threat Sharing** and **Remediating**.  
This guide covers cases of protecting common services such as web servers (HTTP) and SSH.  

Via a **top-down approach** we'll test the end goal of components, and then dive into detailed troubleshooting if needed.

This health check is divided into three main sections:
- [**üì° Detecting**](#-detection-checks) behaviors on your services.
- [**üîó Connectivity**](#-crowdsec-connectivity-checks) with CrowdSec network to retrieve the community blocklist.
- [**üõ°Ô∏è Protecting**](#-remediation-checks) your services by remediating alerts automatically with bouncers.

* * *

## üì° Detection checks

### *Trigger CrowdSec's test scenarios*  

:::info
Check that your Security Engine properly reads and parses the logs of the services you protect.  
The HTTP collection and the Linux collection contain **dummy scenarios** allowing you to prove your Security Engine works as intended, without having to do penetration tests, risking getting you banned from your own server.
:::

<details>
  <summary>üåê **HTTP** detection test</summary>
  
Let's trigger the `crowdsecurity/http-generic-test` dummy scenario by calling a *probe path* on your web server.

1Ô∏è‚É£ Request your service URL with the following path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ You should see an alert for the scenario `crowdsecurity/http-generic-test`

<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/http-generic-test</CodeBlock>

Notes:
- If it's done from a private IP the alert won't appear as private IPs are whitelisted by default.
  - You can call the test url via a browser if you prefer, it might make it easier to test from an other device.
- This scenario has a delay of 5 minutes before it can re-trigger _(blackhole parameter of the scenario)_. 
</details>

<details>
    <summary>üîê **SSH** detection test</summary>

Let's trigger the `crowdsecurity/ssh-generic-test` dummy scenario by logging in to your server via SSH with a specific user.

1Ô∏è‚É£ Try to authenticate to your server via SSH using the following user: `crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`.
<CodeBlock className="language-bash">ssh crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl@\<your-server-ip\></CodeBlock>

2Ô∏è‚É£ You should see an alert for the scenario `crowdsecurity/ssh-generic-test`

<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/ssh-generic-test</CodeBlock>

Note that this scenario has a delay of 5 minute before it can re-trigger _(blackhole parameter of the scenario)_. 
</details>

<details>
    <summary>üõ°Ô∏è **AppSec** detection test - CrowdSec WAF </summary>

If you are using an AppSec-capable bouncer and have configured CrowdSec WAF, you can test the detection of an AppSec scenario.
It's similar to the HTTP detection test, but it will trigger `crowdsecurity/appsec-generic-test`.

Here is how to trigger the `crowdsecurity/appsec-generic-test` dummy scenario by calling a *probe path* on your web server.

1Ô∏è‚É£ Request your service URL with the following path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I http://your-service-url/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ You should see an alert for the scenario `crowdsecurity/appsec-generic-test`

<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/appsec-generic-test</CodeBlock>

Note that this scenario has a delay of **1** minute before it can re-trigger _(blackhole parameter of the scenario)_. 
</details>

* * *

### Were all the tests successful ?

Were all the tests related to your setup successful ?
If so, you can proceed to the next phase of the health check: [**Connectivity checks**](#crowdsec-connectivity-checks).  

If not, check the troubleshooting section below

<details>
    <summary>üö® **Detection Troubleshooting**</summary>

  *No alerts triggered? Let's investigate: Here are some tests to identify where the issue might be.*  

  If you installed **CrowdSec Security Engine** on the same **Host** as the service you want to protect, the install wizards should have automatically detected the service and installed the appropriate parsers and scenarios.  

  If you have non-default paths or format for your logs, or if you chose other installation methods (docker, kubernetes..), you may need to manually install the parsers and scenarios.
  
  **This troubleshooting section will help you identify the issue and guide you through the necessary steps to fix it.**

  <details>
      <summary>Are your logs being properly read and parsed?</summary>

  The acquisition and parsing aspect of CrowdSec is crucial, as it tells The Security Engine which logs to read and how to parse them. You can setup multiple datasources (files, syslog, etc.), for more details you can refer to the [datasources documentation](https://doc.crowdsec.net/docs/next/log_processor/data_sources/intro).  

  Let's do a Top Down check using the `cscli metrics` command to see if your logs are being read and parsed correctly.

  <CodeBlock className="language-bash">sudo cscli metrics show acquisition parsers</CodeBlock>

  - You should see the **names of the log files/stream** configured in the acquisition files, and the number of lines parsed for each of them.  
  - The number of "Lines parsed" should be non-zero for each of the files you configured in the acquisition section. 
  - The parsers metrics show you what parsers were successfully used. Look for the name of the parsers installed for the logs you're reading

  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üö® If this command fails, check the [**CrowdSec Service Troubleshooting section**](#troubleshooting_service)
  </div>
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üö® If you don't see the log names supposed to be parsed, check the [**Acquisition Troubleshooting section**](#troubleshooting_acquisition)
  </div>
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üö® If you don't see parsed lines, check the [**Collection Troubleshooting section****](#troubleshooting_collection)
  </div>

  </details>

  <details id="troubleshooting_acquisition">
      <summary>Acquisition Troubleshooting: are your logs properly declared as datasources</summary>

  Your acquisition configuration is located in the `crowdsec` directory under `acquis.yaml` or `acquis.d/anyName.yaml`.  
  The CrowdSec directory changes depending on your OS and installation method, for example, on Debian like OS it is usually located in `/etc/crowdsec/`.  

  You may want to check your current acquisition configuration or [add a new acquisition file](https://doc.crowdsec.net/u/getting_started/post_installation/acquisition_new).
  - Check that the datasource is properly setup: file path or correct port for syslog server...
  - Ensure that the type declared matches the parser expected to be used: nginx, apache, syslog, etc.
  - for more information, check the [documentation for the various datasources](https://doc.crowdsec.net/docs/next/log_processor/data_sources/intro)
  </details>

  <details id="troubleshooting_collection">
      <summary>Collection Troubleshooting: are the parsers and scenarios installed?</summary>

  #### Collection installation
  - On host installations your existing service should have been detected and appropriate collections (containing parsers and scenarios) installed automatically.
  - How ever on other kind of installations, or in case of failed detection, you may need to install the collections manually.

  Check the installed collections with the command:
  <CodeBlock className="language-bash">sudo cscli collections list</CodeBlock>
  You can also list individual parsers and scenarios with:
  <CodeBlock className="language-bash">sudo cscli parsers list</CodeBlock>
  <CodeBlock className="language-bash">sudo cscli scenarios list</CodeBlock>
  - If you see the parsers and scenarios related to your service, then you're good to go.

  - To install new collection, check the [CrowdSec Hub](https://hub.crowdsec.net/) for a collection named after your service (e.g., [nginx](https://app.crowdsec.net/hub/author/crowdsecurity/collections/nginx), [apache](https://app.crowdsec.net/hub/author/crowdsecurity/collections/apache), [linux](https://app.crowdsec.net/hub/author/crowdsecurity/collections/linux), etc.).
  - If you find the collection, install it using the command shown on the hub page and follow the instructions provided for the acquisition file.

  #### Log format mismatch
  - If your logs are in a custom format, you may need to create your own parsers or modify the existing ones to match your log format.
  - You can find more information on how to create your own parsers in the [CrowdSec documentation](https://doc.crowdsec.net/docs/next/log_processor/parsers/format).

  </details>

  <details id="troubleshooting_service">
      <summary>CrowdSec Service Troubleshooting: is the CrowdSec service running?</summary>
  Make sure the CrowdSec service is running properly. You can check the status of the service with the following command:
  <CodeBlock className="language-bash">sudo systemctl status crowdsec</CodeBlock> 
  - You should see the service status as "active (running)".

  If the service is not running, you can start it with the following command:
  <CodeBlock className="language-bash">sudo systemctl start crowdsec</CodeBlock>

  If the service fails to start, you can check the logs for more information:
  <CodeBlock className="language-bash">sudo journalctl -u crowdsec</CodeBlock>

  Reasons for the service not running can include:
  - Misconfiguration in the `config.yaml` file.
    - Port conflicts with other services. By default, CrowdSec uses port 8080 for the Local API (LAPI) and port 6060 for the Local API metrics.
    - The port configuration can be setup in `config.yaml` file or by setting the environment variables depending on your implementation
  - Insufficient permissions to access the log files or directories.
  - Acquisition files format errors.

  </details>
</details>

## üîå CrowdSec Connectivity checks

### *List the community-blocked IPs*  

Let's check that your Security Engine can communicate with the CrowdSec Central API (CAPI). This connection is essential for participating in the community and protecting your setup with the collective intelligence of the network.  
The CAPI allows your instance to receive a curated blocklist of malicious IP addresses identified and verified by the entire CrowdSec network. This proactive defense, known as the Community Blocklist, protects you from aggressors before they even target your services. It also allows your Security Engine to report the malicious IPs it detects, contributing to the strength of the community.

<details>
  <summary>üîå CrowdSec Central API connectivity</summary>

  The most direct way to verify connectivity is to see if your instance has already received decisions from the community blocklist.

  1Ô∏è‚É£ List decisions coming from CAPI
  
  <CodeBlock className="language-bash">sudo cscli decisions list --origin CAPI </CodeBlock>

  2Ô∏è‚É£ If you see decisions listed, it means your Security Engine is successfully connected to the CAPI and receiving decisions.
</details>

### Were all the tests successful ?

<details>
    <summary>üö® Connectivity Troubleshooting</summary>

  Check CAPI status with the command:
  <CodeBlock className="language-bash">sudo cscli capi status</CodeBlock>
  - Should show: "You can successfully interact with Central API (CAPI)"
  - If this test fail, try to enrol to the console to check what's going on.

  Other common issues that can prevent your Security Engine from connecting to the CAPI include:
  - Check that the online api credentials `online_api_credentials.yaml` exist in your crowdsec config directory
    - If they don't exist, you can create them by running the command:
      <CodeBlock className="language-bash">sudo cscli capi register</CodeBlock>
  - Check that the `crowdsec` service is running and properly configured to connect to the CAPI.
  - Firewall rules blocking outbound connections to the CrowdSec Central API.
  - DNS resolution issues.
  - Proxy server configuration.
  - Connectivity issues within Docker containers.

</details>

## ‚úãüèª Remediation checks

### *Validate Blocks or Captchas* 

Now that we've confirmed that the Security Engine can detect threats, let's verify that your bouncers are correctly applying decisions and blocking malicious IPs.

::info A note on future improvements
In the future, this health-check will include an option to trigger a remote test from the CrowdSec Console, which will safely probe your defenses from an external IP.
For now, we will perform a manual test by temporarily banning your own IP address. Please read the following warning carefully before proceeding.
:::

<details>
  <summary>‚úãüèª Bouncer Remediation test</summary>

This test involves manually creating a ban decision against your own public IP address for a very short period (1 minute).  

::danger BE CAREFUL: Risk of Self-Lockout
This procedure will temporarily block your access to the services protected by your bouncer.  
Make sure to properly set the TTL to a low expiration time (1 minute). OR do it from a device with a different public IP address than the client you're using to setup CrowdSec.
::

1Ô∏è‚É£ Find out you public address by using the following command:
<CodeBlock className="language-bash">curl api.ipify.org</CodeBlock>
or
<CodeBlock className="language-bash">curl curl ipinfo.io/ip</CodeBlock>

2Ô∏è‚É£ Create a ban decision for your public IP address with a TTL of 1 minute:
<CodeBlock className="language-bash">sudo cscli decisions add ban --ip \<your-public-ip\> --duration 1m --reason "CrowdSec remediation test"</CodeBlock>

3Ô∏è‚É£ Try to access your service (website, api ...) from the same public IP address. \> You should be blocked by the bouncer.

4Ô∏è‚É£ Wait for 1 minute, then check the decisions list to see if the decision has been removed

</details>

### Were all the tests successful ?

If you were successfully blocked, congratulations! Your remediation setup is working correctly. üéâ  

You might want to continue to the next recommended steps:
- Enroll your Security Engine to the [CrowdSec Console](/u/getting_started/post_installation/console/)
- Then subscribe to more blocklists to benefit from additionnl proactive prevention

<details>
    <summary>üö® **Remediation Troubleshooting**</summary>

  ...

  <details>
      <summary>Bouncer Configuration Troubleshooting</summary>
      
  *   Verifying that the bouncer is registered and active.
  *   Checking bouncer logs for errors.
  *   Troubleshooting communication issues between the bouncer and the CrowdSec LAPI.
  *   Firewall configuration for the bouncer.
  *   Specific troubleshooting steps for common bouncers (firewall-bouncer, nginx-bouncer, etc.).)

  </details>

  <details>
      <summary>Profile Troubleshooting</summary>

  *   Verifying profile configuration.
  *   Troubleshooting errors related to profile application.
  *   Understanding the impact of profiles on detection and remediation.)

  </details>
</details>

## Your feedback is important!

If you have any suggestions or improvements for this health check, please let us know by opening an issue on our [GitHub repository](https://github.com/crowdsecurity/crowdsec-docs/issues/new) or on our [discord](https://discord.gg/wGN7ShmEE8)