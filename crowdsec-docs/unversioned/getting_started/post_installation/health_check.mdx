---
id: health_check
title: CrowdSec Security Engine Setup Health-Check
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import CodeBlock from '@theme/CodeBlock';
import { CheckboxProvider, InteractiveCheckbox } from '@site/src/components/InteractiveCheckbox.js';
import HierarchicalList from '@site/src/components/HierarchicalList.js';

<small className="health-check-version" style={{position: 'relative', top: '-30px'}}>Health Check Version: 0.1.0</small>

Welcome to the interactive Health-Check of your CrowdSec setup.  
We'll guide you through a series of tests to ensure that your Security Stack is fully functional and ready to protect your services:  
**Detecting**, **Threat Sharing** and **Remediating**.  
*This guide covers cases of protecting common services such as web servers (HTTP) and SSH.*   

We'll first test the final functionality of each component (top-down approach) before diving into detailed troubleshooting if issues arise.

This health check is divided into three main sections:
- [**üì° Detection**](#-detection-checks): Ensuring CrowdSec properly detects threats targeting your services.
- [**üîó Connectivity**](#-crowdsec-connectivity-checks): Verifying communication with the CrowdSec network to receive the community blocklist.
- [**üõ°Ô∏è Protection**](#-remediation-checks): Confirming that your bouncers automatically block threats detected by CrowdSec

* * *

## üì° Detection checks

### *Trigger CrowdSec's test scenarios*  

Let's use CrowdSec's built-in **dummy scenarios** (HTTP and Linux) to safely verify your Security Engine detects threats, without risking accidental self-blocking.

<details>
  <summary>üåê **HTTP** detection test</summary>
  
We'll trigger the dummy scenario `crowdsecurity/http-generic-test` by accessing a **probe path** on your web server.

1Ô∏è‚É£ Access your service URL with this path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/http-generic-test`
<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/http-generic-test</CodeBlock>

**Notes:**  
- Requests from private IP addresses won't trigger alerts (private IPs are whitelisted by default).
  - You can also test via a browser if easier, especially from another device.
- This scenario can be triggered again only after a 5-minutes delay.
</details>

<details>
    <summary>üîê **SSH** detection test</summary>

We'll trigger the dummy scenario `crowdsecurity/ssh-generic-test` by attempting an SSH login with a specific username.

1Ô∏è‚É£ Attempt SSH login using this username: `crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`.
<CodeBlock className="language-bash">ssh crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl@\<your-server-ip\></CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/ssh-generic-test`
<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/ssh-generic-test</CodeBlock>

**Notes:** 
- This scenario can only be triggered again after a 5-minutes delay. 
</details>

<details>
    <summary>üõ°Ô∏è **AppSec** detection test - CrowdSec WAF </summary>

If you've enabled an AppSec-capable bouncer with CrowdSec WAF, you can trigger the `crowdsecurity/appsec-generic-test` dummy scenario.  
It would have triggered along with the HTTP detection test, but it is worth mentioning here as well.  

Here is how to trigger the `crowdsecurity/appsec-generic-test` dummy scenario by calling a *probe path* on your web server.

We'll trigger the dummy scenario `crowdsecurity/appsec-generic-test` by accessing a **probe path** on your web server.

1Ô∏è‚É£ Access your service URL with this path: `/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl`
<CodeBlock className="language-bash">curl -I https://\<your-service-url\>/crowdsec-test-NtktlJHV4TfBSK3wvlhiOBnl</CodeBlock>

2Ô∏è‚É£ Confirm the alert has triggered for the scenario `crowdsecurity/appsec-generic-test`
<CodeBlock className="language-bash">sudo cscli alerts list -s crowdsecurity/appsec-generic-test</CodeBlock>

**Notes:**
- This scenario can only be triggered again after a 1-minute delay. 
</details>

* * *

### Were all the tests successful ?

Were all the tests related to your setup successful? 
üëç If so, you can proceed to the next phase of the health check: [**Connectivity checks**](#-crowdsec-connectivity-checks).  

üõ†Ô∏è If not, check the troubleshooting section below.

<details>
    <summary>üêû **Detection Troubleshooting**</summary>

  **No alert triggered? Let's find out why.**   

  If you installed CrowdSec on the same **host** as the service you're protecting, it should have auto-detected it and installed the right collections of parsers and scenarios.
  However, if you're using *custom log paths*, *unusual log formats*, or running in *Docker/Kubernetes*, you might need to configure some things manually.  
  
 **This section will help you pinpoint the issue and walk you through how to fix it.**  

  <details>
      <summary>üìÑ Are your logs being properly read and parsed?</summary>

  CrowdSec needs to know what logs to read and how to interpret them.  
  This is handled by the acquisition configuration (log sources) and parsing (how to read them).
  Multiple log sources can be defined in the acquisition(s) configuration files and they support diverse datasources (files, syslog, etc.).
  For more details you can refer to the [datasources documentation](https://doc.crowdsec.net/docs/next/log_processor/data_sources/intro).  

  We'll look at the security engine **metrics** to see if logs are **being read** and if what's read is **parsed correctly**.  
  We'll do that using the `cscli metrics` command:
  <CodeBlock className="language-bash">sudo cscli metrics show acquisition parsers</CodeBlock>

  Under **Acquisition Metrics** you should see:
  - The source name of the log files or streams that have been read and the number of lines read and parsed for each of them.
    - If you don't see any sources or some you have configured are missing, it means that the acquisition configuration is not properly set up. 
    - A non zero number of "Lines parsed" is expected for each source, proving that the appropriate parser was found and used.
  
  Under The **Parsers Metrics** you have the details of the parsers used.

  üö® If this check fails, don‚Äôt worry -- the results will point you to the right area to troubleshoot:  
  
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üêû If this command fails entirely, go to the [**CrowdSec Service Troubleshooting section**](#troubleshooting_service)
  </div>
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üêû If your acquisition sources don't appear, check the [**Acquisition Troubleshooting section**](#troubleshooting_acquisition)
  </div>
  <div style={{ backgroundColor: '#FFE5B4', borderRadius: '5px' }}>
    üêû If parsing fails, check the [**Collection Troubleshooting section****](#troubleshooting_collection)
  </div>

  </details>

  <details id="troubleshooting_acquisition">
      <summary>üì• Acquisition Troubleshooting -- Are your logs properly declared as datasources</summary>

  CrowdSec needs to know where to **read your logs**. This is handled by the **acquisition configuration**, usually found in `acquis.yaml` or in files under `acquis.d/` inside the CrowdSec config directory.  
  On Debian like OS it is typically located in `/etc/crowdsec/`.  

  To troubleshoot:
  - The detailed doc about the acquisition configuration can be found [here](https://doc.crowdsec.net/docs/next/log_processor/acquisition/intro).
  - Check your acquisition files exist and that the datasources are properly setup.
  - üí° Hint: 
    - The hub page of the collection you installed provides an example of the acquisition configuration file to create.
    - For example:
      - The [NGINX collection hub page](https://app.crowdsec.net/hub/author/crowdsecurity/collections/nginx) 
      - Or the [SSHD collection hub page](https://app.crowdsec.net/hub/author/crowdsecurity/collections/sshd) (that is contained in the Linux Collection).
  - Make sure that the **type** declared in the matches the **parser** expected to be used: nginx, apache, syslog, etc.
  </details>

  <details id="troubleshooting_collection">
      <summary>üì¶ Collection Troubleshooting -- Are the right parsers and scenarios installed?</summary>

  CrowdSec, via its [**Hub**](https://app.crowdsec.net/hub/collections) uses collections to package correct parsers and detection scenarios for your services.
  - On regular **host** installations, CrowdSec usually detects your services (like nginx or ssh) and installs the appropriate collections automatically.
  - On **Docker**, **Kubernetes**, or **custom setups**, you may need to install them manually.

  #### üîç To check what's currently installed:
  <CodeBlock className="language-bash">sudo cscli collections list</CodeBlock>

  You can also list individual parsers and scenarios with:
  <CodeBlock className="language-bash">sudo cscli parsers list</CodeBlock>
  <CodeBlock className="language-bash">sudo cscli scenarios list</CodeBlock>
  
  - Look for entries related to your service (e.g., nginx, apache, ssh).
  - If they‚Äôre listed, the right collection is likely installed.

  #### üì• Install missing collections
  1. Visit the [CrowdSec Hub](https://hub.crowdsec.net/) and search for a collection matching your service, like:
    - [nginx](https://app.crowdsec.net/hub/author/crowdsecurity/collections/nginx)
    - [apache](https://app.crowdsec.net/hub/author/crowdsecurity/collections/apache)
    - [linux](https://app.crowdsec.net/hub/author/crowdsecurity/collections/linux)
    - etc...
  2. Follow the installation instructions on the collection‚Äôs page, including any required acquisition setup.

  #### ‚ö†Ô∏è Log format mismatch
  - If your logs don‚Äôt follow the expected format (e.g., they‚Äôve been customized), CrowdSec might not parse them properly.
  - You can find more information on how to create your own parsers in the [CrowdSec documentation](https://doc.crowdsec.net/docs/next/log_processor/parsers/format).

  </details>

  <details id="troubleshooting_service">
      <summary>‚öôÔ∏è CrowdSec Service Troubleshooting -- is the CrowdSec service running?</summary>

  Let‚Äôs check if the CrowdSec service is active:
  <CodeBlock className="language-bash">sudo systemctl status crowdsec</CodeBlock> 
  - ‚òëÔ∏è You should see: "**active (running)**"

  If the service is not running, you can start it manually:
  <CodeBlock className="language-bash">sudo systemctl start crowdsec</CodeBlock>
  - üí° make sure it will be up after restart, activate the service

  If the service fails to start, you can check the logs for more information:
  <CodeBlock className="language-bash">sudo journalctl -u crowdsec</CodeBlock>

  Common reasons the service might fail::
  - Misconfiguration in the `config.yaml` file.
    - Port conflicts with other services. By default, CrowdSec uses port 8080 for the Local API (LAPI) and port 6060 for the Local API metrics.
    - The port configuration can be setup in `config.yaml` file or by setting the environment variables depending on your implementation
  - Insufficient permissions to access the log files or directories.
  - Acquisition files format errors.

  </details>
</details>

## üîå CrowdSec Connectivity checks

### *List the community-blocked IPs*  

Let's check that your Security Engine can communicate with the CrowdSec Central API (CAPI). This connection is essential for participating in the community and protecting your setup with the collective intelligence of the network.  
The CAPI allows your instance to receive a curated blocklist of malicious IP addresses identified and verified by the entire CrowdSec network. This proactive defense, known as the Community Blocklist, protects you from aggressors before they even target your services. It also allows your Security Engine to report the malicious IPs it detects, contributing to the strength of the community.

<details>
  <summary>üîå CrowdSec Central API connectivity</summary>

  The most direct way to verify connectivity is to see if your instance has already received decisions from the community blocklist.

  1Ô∏è‚É£ List decisions coming from CAPI
  
  <CodeBlock className="language-bash">sudo cscli decisions list --origin CAPI </CodeBlock>

  2Ô∏è‚É£ If you see decisions listed, it means your Security Engine is successfully connected to the CAPI and receiving decisions.
</details>

### Were all the tests successful ?

<details>
    <summary>üêû Connectivity Troubleshooting</summary>

  Check CAPI status with the command:
  <CodeBlock className="language-bash">sudo cscli capi status</CodeBlock>
  - Should show: "You can successfully interact with Central API (CAPI)"
  - If this test fail, try to enrol to the console to check what's going on.

  Other common issues that can prevent your Security Engine from connecting to the CAPI include:
  - Check that the online api credentials `online_api_credentials.yaml` exist in your crowdsec config directory
    - If they don't exist, you can create them by running the command:
      <CodeBlock className="language-bash">sudo cscli capi register</CodeBlock>
  - Check that the `crowdsec` service is running and properly configured to connect to the CAPI.
  - Firewall rules blocking outbound connections to the CrowdSec Central API.
  - DNS resolution issues.
  - Proxy server configuration.
  - Connectivity issues within Docker containers.

</details>

## ‚úãüèª Remediation checks

### *Validate Blocks or Captchas* 

Now that we've confirmed that the Security Engine can detect threats, let's verify that your bouncers are correctly applying decisions and blocking malicious IPs.

::info A note on future improvements
In the future, this health-check will include an option to trigger a remote test from the CrowdSec Console, which will safely probe your defenses from an external IP.
For now, we will perform a manual test by temporarily banning your own IP address. Please read the following warning carefully before proceeding.
:::

<details>
  <summary>‚úãüèª Bouncer Remediation test</summary>

This test involves manually creating a ban decision against your own public IP address for a very short period (1 minute).  

::danger BE CAREFUL: Risk of Self-Lockout
This procedure will temporarily block your access to the services protected by your bouncer.  
Make sure to properly set the TTL to a low expiration time (1 minute). OR do it from a device with a different public IP address than the client you're using to setup CrowdSec.
::

1Ô∏è‚É£ Find out you public address by using the following command:
<CodeBlock className="language-bash">curl api.ipify.org</CodeBlock>
or
<CodeBlock className="language-bash">curl curl ipinfo.io/ip</CodeBlock>

2Ô∏è‚É£ Create a ban decision for your public IP address with a TTL of 1 minute:
<CodeBlock className="language-bash">sudo cscli decisions add ban --ip \<your-public-ip\> --duration 1m --reason "CrowdSec remediation test"</CodeBlock>

3Ô∏è‚É£ Try to access your service (website, api ...) from the same public IP address. \> You should be blocked by the bouncer.

4Ô∏è‚É£ Wait for 1 minute, then check the decisions list to see if the decision has been removed

</details>

### Were all the tests successful ?

If you were successfully blocked, congratulations! Your remediation setup is working correctly. üéâ  

You might want to continue to the next recommended steps:
- Enroll your Security Engine to the [CrowdSec Console](/u/getting_started/post_installation/console/)
- Then subscribe to more blocklists to benefit from additionnl proactive prevention

<details>
    <summary>üêû **Remediation Troubleshooting**</summary>

  ...

  <details>
      <summary>Bouncer Configuration Troubleshooting</summary>
      
  *   Verifying that the bouncer is registered and active.
  *   Checking bouncer logs for errors.
  *   Troubleshooting communication issues between the bouncer and the CrowdSec LAPI.
  *   Firewall configuration for the bouncer.
  *   Specific troubleshooting steps for common bouncers (firewall-bouncer, nginx-bouncer, etc.).)

  </details>

  <details>
      <summary>Profile Troubleshooting</summary>

  *   Verifying profile configuration.
  *   Troubleshooting errors related to profile application.
  *   Understanding the impact of profiles on detection and remediation.)

  </details>
</details>

## Your feedback is important!

If you have any suggestions or improvements for this health check, please let us know by opening an issue on our [GitHub repository](https://github.com/crowdsecurity/crowdsec-docs/issues/new) or on our [discord](https://discord.gg/wGN7ShmEE8)